<h1>Robuffer</h1> <p><strong>Author:</strong> M1778M<br> <strong>Language:</strong> Luau (Roblox)<br> <strong>Category:</strong> Binary Serialization Library</p> <h2>Overview</h2> <p> Robuffer is a deterministic binary serialization and deserialization library for Luau. It converts Lua values into compact Roblox <code>buffer</code> objects and restores them back into native Lua structures with full type fidelity. </p> <p> The library is designed for performance-critical environments such as networking, persistent storage, and binary protocols. </p> <h2>Key Features</h2> <ul> <li>Automatic data type inference</li> <li>Compact binary layout</li> <li>Nested table serialization</li> <li>Array and dictionary table detection</li> <li>Configurable metadata size types</li> <li>Safe validation with depth and size limits</li> <li>Deterministic serialization format</li> </ul> <h2>Supported Data Types</h2> <table> <thead> <tr> <th>Lua Type</th> <th>Robuffer DataType</th> <th>Size (bytes)</th> </tr> </thead> <tbody> <tr><td>string</td><td>String</td><td>Variable</td></tr> <tr><td>boolean</td><td>Boolean</td><td>1</td></tr> <tr><td>number (0–255)</td><td>U8</td><td>1</td></tr> <tr><td>number (0–65535)</td><td>U16</td><td>2</td></tr> <tr><td>number (0–4294967295)</td><td>U32</td><td>4</td></tr> <tr><td>number (-128–127)</td><td>I8</td><td>1</td></tr> <tr><td>number (-32768–32767)</td><td>I16</td><td>2</td></tr> <tr><td>number (-2147483648–2147483647)</td><td>I32</td><td>4</td></tr> <tr><td>float (small)</td><td>Float32</td><td>4</td></tr> <tr><td>float (large)</td><td>Float64</td><td>8</td></tr> <tr><td>table</td><td>Table</td><td>Variable</td></tr> </tbody> </table> <h2>Table Serialization</h2> <h3>Array Tables</h3> <p> A table is considered an array when all keys are sequential positive integers starting at 1. </p> <pre> [type = 1][count][element1][element2]...[elementN] </pre> <h3>Dictionary Tables</h3> <p> Any non-array table is serialized as a dictionary. </p> <pre> [type = 2][count][key1][value1][key2][value2]... </pre> <p> Numeric keys are serialized as strings and converted back during deserialization. </p> <h2>Safety Limits</h2> <ul> <li>Maximum nesting depth: 10</li> <li>Maximum table size: 10,000 entries</li> <li>Allowed key types: string, number</li> <li>Allowed value types: string, number, boolean, table</li> </ul> <h2>Installation</h2> <pre> local Robuffer = require(game:GetService("ReplicatedStorage"):WaitForChild("Packages").Robuffer) </pre> <h2>Basic Usage</h2> <h3>Create and Serialize</h3> <pre><code class="language-lua">local rb = Robuffer.new(3)
rb:AddItem(123)
rb:AddItem("Hello")
rb:AddItem(true)
local buf = rb:Serialize() 
</code></pre> <h3>Deserialize</h3> 
<pre><code class="language-lua">local values = Robuffer.Deserialize(buf)
-- {123, "Hello", true}</code></pre> <h2>Wrapping an Existing Table</h2> 
<pre><code class="language-lua">local data = {10, 20, "test"}
local rb = Robuffer.wrap(data)
local buffer = rb:Serialize()</code> </pre> <h2>Debug Mode</h2> <pre><code class="language-lua"> rb:SetDebug(true) </code></pre> <p> When enabled, Robuffer prints detailed offset, size, and type information during serialization. </p> <h2>API Reference</h2> <h3>Robuffer.new(elementCount, sizeType?)</h3> <p>Creates a new Robuffer instance.</p> <h3>Robuffer.wrap(table, sizeType?)</h3> <p>Creates a Robuffer from an existing Lua table.</p> <h3>Robuffer:AddItem(value)</h3> <p>Adds a serializable value to the buffer.</p> <h3>Robuffer:SetItem(index, value)</h3> <p>Replaces an element at a given index.</p> <h3>Robuffer:Clear()</h3> <p>Clears all internal memory.</p> <h3>Robuffer:Serialize()</h3> <p>Serializes all elements into a Roblox buffer.</p> <h3>Robuffer.Deserialize(buffer)</h3> <p>Deserializes a buffer back into Lua values.</p> <h2>Size Types</h2> <pre> Robuffer.SizeTypes = { U8 = 1, U16 = 2, U32 = 3 } </pre> <h2>Data Types Enum</h2> <pre> Robuffer.DataTypes = { U8 = 1, U16 = 2, U32 = 3, I8 = 4, I16 = 5, I32 = 6, Float32 = 7, Float64 = 8, String = 9, Boolean = 10, Table = 11 } </pre> <h2>Binary Layout</h2> <pre> [SizeType] [ElementCountSize] [ElementCount] [Metadata Entries] [Raw Data Section] </pre> <p> Each metadata entry stores an offset, datatype identifier, and size, allowing fast indexed deserialization. </p> <h2>License</h2> <p>The Unlicensed</p>
